<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>tars</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: system-ui, -apple-system, sans-serif; background: #1a1a1a; color: #e0e0e0; height: 100dvh; display: flex; flex-direction: column; }
  #messages { flex: 1; overflow-y: auto; padding: 1rem; display: flex; flex-direction: column; gap: 0.5rem; }
  .msg { max-width: 80%; padding: 0.5rem 0.75rem; border-radius: 0.5rem; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; }
  .msg.user { align-self: flex-end; background: #2563eb; color: #fff; }
  .msg.assistant { align-self: flex-start; background: #2a2a2a; }
  .msg.error { align-self: flex-start; background: #7f1d1d; }
  .msg.thinking { align-self: flex-start; background: #2a2a2a; color: #888; }
  @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
  .msg.thinking { animation: pulse 1.5s ease-in-out infinite; }
  #input-row { display: flex; gap: 0.5rem; padding: 0.75rem 1rem; background: #222; border-top: 1px solid #333; }
  #input { flex: 1; padding: 0.5rem 0.75rem; border: 1px solid #444; border-radius: 0.375rem; background: #2a2a2a; color: #e0e0e0; font-size: 1rem; font-family: inherit; outline: none; }
  #input:focus { border-color: #2563eb; }
  #send { padding: 0.5rem 1rem; border: none; border-radius: 0.375rem; background: #2563eb; color: #fff; font-size: 1rem; cursor: pointer; }
  #send:disabled { opacity: 0.5; cursor: default; }
</style>
</head>
<body>
<div id="messages"></div>
<div id="input-row">
  <input id="input" type="text" placeholder="message tars..." autocomplete="off">
  <button id="send">Send</button>
</div>
<script>
const messages = document.getElementById("messages");
const input = document.getElementById("input");
const send = document.getElementById("send");
const convId = "web-" + Math.random().toString(36).slice(2, 10);

function addMsg(role, text) {
  const div = document.createElement("div");
  div.className = "msg " + role;
  div.textContent = text;
  messages.appendChild(div);
  messages.scrollTop = messages.scrollHeight;
  return div;
}

async function sendMessage() {
  const text = input.value.trim();
  if (!text) return;
  input.value = "";
  addMsg("user", text);
  send.disabled = true;
  input.disabled = true;

  try {
    // POST to the streaming endpoint. The server returns Server-Sent Events
    // (SSE) — a text stream where each line is "data: {json}\n\n".
    const resp = await fetch("/chat/stream", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify({conversation_id: convId, message: text}),
    });

    if (!resp.ok) {
      const err = await resp.json();
      addMsg("error", err.detail || "request failed");
      return;
    }

    // Show a thinking indicator while waiting for the first token.
    // This covers the delay from tool execution and model warmup.
    const thinking = addMsg("thinking", "thinking...");

    // Create an empty assistant message div that we'll append tokens to.
    const div = addMsg("assistant", "");
    div.style.display = "none";
    let firstToken = true;

    // Read the response body as a stream. The browser gives us chunks of
    // bytes — we decode them to text and parse the SSE "data:" lines.
    const reader = resp.body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";

    while (true) {
      const {done, value} = await reader.read();
      if (done) break;

      // Decode the chunk and add it to our buffer. {stream: true} tells
      // the decoder not to flush — important for multi-byte characters
      // that might be split across chunks.
      buffer += decoder.decode(value, {stream: true});

      // SSE events are separated by double newlines. Split on \n and
      // process complete lines, keeping the last (potentially incomplete)
      // line in the buffer.
      const lines = buffer.split("\n");
      buffer = lines.pop();

      for (const line of lines) {
        if (!line.startsWith("data: ")) continue;
        const data = JSON.parse(line.slice(6));
        // Each event is either a text delta or a done signal.
        if (data.delta) {
          if (firstToken) {
            thinking.remove();
            div.style.display = "";
            firstToken = false;
          }
          div.textContent += data.delta;
          messages.scrollTop = messages.scrollHeight;
        }
      }
    }
  } catch (e) {
    if (document.contains(thinking)) thinking.remove();
    addMsg("error", "connection failed: " + e.message);
  } finally {
    send.disabled = false;
    input.disabled = false;
    input.focus();
  }
}

send.addEventListener("click", sendMessage);
input.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); sendMessage(); }
});
input.focus();
</script>
</body>
</html>
