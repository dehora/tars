<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>tars</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: system-ui, -apple-system, sans-serif; background: #1a1a1a; color: #e0e0e0; height: 100dvh; display: flex; flex-direction: column; }
  #messages { flex: 1; overflow-y: auto; padding: 1rem; display: flex; flex-direction: column; gap: 0.5rem; }
  .msg { max-width: 80%; padding: 0.5rem 0.75rem; border-radius: 0.5rem; line-height: 1.4; word-wrap: break-word; }
  .msg.user { white-space: pre-wrap; align-self: flex-end; background: #2563eb; color: #fff; }
  .msg.assistant { align-self: flex-start; background: #2a2a2a; overflow-wrap: break-word; }
  /* Markdown inside assistant messages */
  .msg.assistant p { margin: 0.4em 0; }
  .msg.assistant p:first-child { margin-top: 0; }
  .msg.assistant p:last-child { margin-bottom: 0; }
  .msg.assistant pre { background: #1a1a1a; padding: 0.5rem; border-radius: 0.375rem; overflow-x: auto; margin: 0.4em 0; }
  .msg.assistant code { font-family: ui-monospace, "SF Mono", Menlo, monospace; font-size: 0.9em; }
  .msg.assistant :not(pre) > code { background: #1a1a1a; padding: 0.1em 0.3em; border-radius: 0.25rem; }
  .msg.assistant ul, .msg.assistant ol { margin: 0.4em 0; padding-left: 1.5em; }
  .msg.assistant li { margin: 0.2em 0; }
  .msg.assistant blockquote { border-left: 3px solid #555; padding-left: 0.75rem; margin: 0.4em 0; color: #aaa; }
  .msg.assistant table { border-collapse: collapse; margin: 0.4em 0; }
  .msg.assistant th, .msg.assistant td { border: 1px solid #444; padding: 0.3em 0.6em; }
  .msg.assistant th { background: #333; }
  .msg.assistant h1, .msg.assistant h2, .msg.assistant h3 { margin: 0.5em 0 0.3em; }
  .msg.assistant a { color: #60a5fa; }
  .msg.error { align-self: flex-start; background: #7f1d1d; }
  .msg.thinking { align-self: flex-start; background: #2a2a2a; color: #888; }
  @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
  .msg.thinking { animation: pulse 1.5s ease-in-out infinite; }
  #input-row { display: flex; gap: 0.5rem; padding: 0.75rem 1rem; background: #222; border-top: 1px solid #333; }
  #input { flex: 1; padding: 0.5rem 0.75rem; border: 1px solid #444; border-radius: 0.375rem; background: #2a2a2a; color: #e0e0e0; font-size: 1rem; font-family: inherit; outline: none; }
  #input:focus { border-color: #2563eb; }
  #send { padding: 0.5rem 1rem; border: none; border-radius: 0.375rem; background: #2563eb; color: #fff; font-size: 1rem; cursor: pointer; }
  #send:disabled { opacity: 0.5; cursor: default; }
</style>
</head>
<body>
<div id="messages"></div>
<div id="input-row">
  <input id="input" type="text" placeholder="message tars..." autocomplete="off">
  <button id="send">Send</button>
</div>
<script src="/marked.min.js"></script>
<script>
// Configure marked for GitHub-Flavored Markdown.
marked.use({gfm: true, breaks: true});

const messages = document.getElementById("messages");
const input = document.getElementById("input");
const send = document.getElementById("send");

// Persist conversation ID in localStorage so the same server-side
// conversation is resumed after a page reload.
const STORAGE_KEY = "tars_conversation";
let convId = localStorage.getItem("tars_convId");
if (!convId) {
  convId = "web-" + Math.random().toString(36).slice(2, 10);
  localStorage.setItem("tars_convId", convId);
}

// --- localStorage history ---
// Store as a JSON array of {role, text} objects. Capped to avoid
// localStorage bloat (5MB limit shared with the whole origin).
const MAX_HISTORY = 200;

function loadHistory() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch { return []; }
}

function saveHistory(history) {
  try {
    // Keep only the most recent messages if we're over the cap.
    const trimmed = history.slice(-MAX_HISTORY);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(trimmed));
  } catch { /* localStorage full or unavailable — ignore */ }
}

function clearConversation() {
  localStorage.removeItem(STORAGE_KEY);
  localStorage.removeItem("tars_convId");
  convId = "web-" + Math.random().toString(36).slice(2, 10);
  localStorage.setItem("tars_convId", convId);
  messages.innerHTML = "";
  history = [];
}

let history = loadHistory();

function addMsg(role, text) {
  const div = document.createElement("div");
  div.className = "msg " + role;
  // Render assistant messages as GFM markdown; everything else as plain text.
  if (role === "assistant") {
    div.innerHTML = marked.parse(text);
  } else {
    div.textContent = text;
  }
  messages.appendChild(div);
  messages.scrollTop = messages.scrollHeight;
  return div;
}

// Restore previous messages on page load.
for (const entry of history) {
  addMsg(entry.role, entry.text);
}

function parseToolCommand(text) {
  const parts = text.split(/\s+/);
  const cmd = parts[0];
  if (cmd === "/todoist") {
    const sub = parts[1] || "";
    if (sub === "add" && parts.length > 2) {
      const flags = new Set(["--due", "--project", "--priority"]);
      const args = {content: ""};
      const content = [];
      for (let i = 2; i < parts.length; i++) {
        if (flags.has(parts[i]) && i + 1 < parts.length) {
          const flag = parts[i].slice(2);
          const vals = [];
          i++;
          while (i < parts.length && !flags.has(parts[i])) { vals.push(parts[i++]); }
          i--;
          args[flag] = flag === "priority" ? parseInt(vals.join(" ")) : vals.join(" ");
        } else { content.push(parts[i]); }
      }
      args.content = content.join(" ");
      return {name: "todoist_add_task", args};
    }
    if (sub === "today") return {name: "todoist_today", args: {}};
    if (sub === "upcoming") { const d = parseInt(parts[2]); return {name: "todoist_upcoming", args: {days: Number.isNaN(d) ? 7 : d}}; }
    if (sub === "complete" && parts.length > 2) return {name: "todoist_complete_task", args: {ref: parts.slice(2).join(" ")}};
    return null;
  }
  if (cmd === "/weather") return {name: "weather_now", args: {}};
  if (cmd === "/forecast") return {name: "weather_forecast", args: {}};
  if (cmd === "/memory") return {name: "memory_recall", args: {}};
  if (cmd === "/remember" && parts.length >= 3) return {name: "memory_remember", args: {section: parts[1], content: parts.slice(2).join(" ")}};
  if (cmd === "/note" && parts.length >= 2) return {name: "note_daily", args: {content: parts.slice(1).join(" ")}};
  if (cmd === "/note") return "usage";
  return null;
}

async function sendMessage() {
  const text = input.value.trim();
  if (!text) return;

  // /clear command — reset conversation locally and on server.
  if (text === "/clear") {
    input.value = "";
    try { fetch("/conversations/" + convId, {method: "DELETE"}); } catch {}
    clearConversation();
    return;
  }

  // /help — show available commands.
  if (text === "/help") {
    input.value = "";
    addMsg("assistant", [
      "**tools:**",
      "`/todoist add <text> [--due D] [--project P] [--priority N]`",
      "`/todoist today|upcoming [days]|complete <ref>`",
      "`/weather` — current conditions",
      "`/forecast` — today's hourly forecast",
      "`/memory` — show persistent memory",
      "`/remember <semantic|procedural> <text>`",
      "`/note <text>` — append to today's daily note",
      "**search:**",
      "`/search <query>` — hybrid keyword + semantic",
      "`/sgrep <query>` — keyword (FTS5/BM25)",
      "`/svec <query>` — semantic (vector KNN)",
      "**sessions:**",
      "`/sessions` — list recent sessions",
      "`/session <query>` — search session logs",
      "**feedback:**",
      "`/w [note]` — flag last response as wrong",
      "`/r [note]` — flag last response as good",
      "**daily:**",
      "`/brief` — todoist + weather digest",
      "`/clear` — reset conversation",
      "`/help` — this help",
    ].join("\n"));
    return;
  }

  // CLI-only interactive commands.
  if (text === "/review" || text === "/tidy" || text.startsWith("/capture")) {
    input.value = "";
    addMsg("assistant", `\`${text}\` is only available in the CLI`);
    return;
  }

  // /w [note] — flag last response as wrong; /r [note] — flag as good.
  const fbMatch = text.match(/^\/([wr])(?:\s(.*))?$/);
  if (fbMatch) {
    input.value = "";
    const kind = fbMatch[1] === "r" ? "reward" : "correction";
    const note = (fbMatch[2] || "").trim();
    try {
      const resp = await fetch("/feedback", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({conversation_id: convId, note, kind}),
      });
      const data = await resp.json();
      addMsg("assistant", resp.ok ? data.message : (data.detail || "feedback failed"));
    } catch (e) {
      addMsg("error", "feedback failed: " + e.message);
    }
    return;
  }

  // /brief — compound command, uses dedicated endpoint.
  if (text === "/brief") {
    input.value = "";
    addMsg("user", text);
    try {
      const resp = await fetch("/brief");
      const data = await resp.json();
      const lines = [];
      for (const [name, content] of Object.entries(data.sections)) {
        const label = name.replace("todoist_today", "tasks").replace("weather_now", "weather").replace("weather_forecast", "forecast");
        lines.push(`**[${label}]**\n${content}`);
      }
      addMsg("assistant", lines.join("\n\n"));
    } catch (e) {
      addMsg("error", "brief failed: " + e.message);
    }
    return;
  }

  // /sessions — list recent sessions.
  if (text === "/sessions") {
    input.value = "";
    addMsg("user", text);
    try {
      const resp = await fetch("/sessions");
      const data = await resp.json();
      if (!data.sessions.length) {
        addMsg("assistant", "no sessions found");
      } else {
        const lines = data.sessions.map(s => `\`${s.date}\`  ${s.title}`);
        addMsg("assistant", lines.join("\n"));
      }
    } catch (e) {
      addMsg("error", "sessions failed: " + e.message);
    }
    return;
  }

  // /session (bare) — show usage hint.
  if (text === "/session") {
    input.value = "";
    addMsg("assistant", "usage: `/session <query>`");
    return;
  }

  // /session <query> — search session logs.
  if (text.startsWith("/session ")) {
    const query = text.slice(9).trim();
    if (!query) { addMsg("assistant", "usage: /session <query>"); input.value = ""; return; }
    input.value = "";
    addMsg("user", text);
    try {
      const resp = await fetch("/sessions/search?q=" + encodeURIComponent(query));
      const data = await resp.json();
      if (!data.results.length) {
        addMsg("assistant", "no session results");
      } else {
        const lines = data.results.map((r, i) =>
          `**${i+1}.** [${r.score.toFixed(3)}] ${r.file_title}:${r.start_line}-${r.end_line}\n${r.content.slice(0, 200)}`
        );
        addMsg("assistant", lines.join("\n\n"));
      }
    } catch (e) {
      addMsg("error", "session search failed: " + e.message);
    }
    return;
  }

  // /search, /sgrep, /svec — memory search commands.
  const searchMatch = text.match(/^\/(search|sgrep|svec)(?:\s(.*))?$/);
  if (searchMatch) {
    const mode = {search: "hybrid", sgrep: "fts", svec: "vec"}[searchMatch[1]];
    const query = (searchMatch[2] || "").trim();
    if (!query) { addMsg("assistant", `usage: /${searchMatch[1]} <query>`); input.value = ""; return; }
    input.value = "";
    addMsg("user", text);
    try {
      const resp = await fetch(`/search?q=${encodeURIComponent(query)}&mode=${mode}`);
      const data = await resp.json();
      if (!resp.ok) { addMsg("error", data.detail || "search failed"); return; }
      if (!data.results.length) {
        addMsg("assistant", `no results (${mode})`);
      } else {
        const lines = data.results.map((r, i) =>
          `**${i+1}.** [${r.score.toFixed(3)}] ${r.file_title || r.file_path}:${r.start_line}-${r.end_line} (${r.memory_type})\n${r.content.slice(0, 200)}`
        );
        addMsg("assistant", lines.join("\n\n"));
      }
    } catch (e) {
      addMsg("error", "search failed: " + e.message);
    }
    return;
  }

  // Direct tool commands — bypass the model entirely.
  const toolCmd = parseToolCommand(text);
  if (toolCmd === "usage") {
    input.value = "";
    addMsg("assistant", "usage: `/note <text>`");
    return;
  }
  if (toolCmd) {
    input.value = "";
    addMsg("user", text);
    try {
      const resp = await fetch("/tool", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(toolCmd),
      });
      const data = await resp.json();
      addMsg("assistant", resp.ok ? data.result : (data.detail || "tool failed"));
    } catch (e) {
      addMsg("error", "tool failed: " + e.message);
    }
    return;
  }

  input.value = "";
  addMsg("user", text);
  history.push({role: "user", text});
  saveHistory(history);
  send.disabled = true;
  input.disabled = true;

  try {
    const resp = await fetch("/chat/stream", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify({conversation_id: convId, message: text}),
    });

    if (!resp.ok) {
      const err = await resp.json();
      addMsg("error", err.detail || "request failed");
      return;
    }

    const thinking = addMsg("thinking", "thinking...");
    const div = addMsg("assistant", "");
    div.style.display = "none";
    let firstToken = true;
    let rawText = "";  // accumulate raw markdown source

    const reader = resp.body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";

    while (true) {
      const {done, value} = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, {stream: true});
      const lines = buffer.split("\n");
      buffer = lines.pop();

      for (const line of lines) {
        if (!line.startsWith("data: ")) continue;
        const data = JSON.parse(line.slice(6));
        if (data.delta) {
          if (firstToken) {
            thinking.remove();
            div.style.display = "";
            firstToken = false;
          }
          rawText += data.delta;
          div.innerHTML = marked.parse(rawText);
          messages.scrollTop = messages.scrollHeight;
        }
      }
    }

    // Save the raw markdown source so history restores render correctly.
    if (rawText) {
      history.push({role: "assistant", text: rawText});
      saveHistory(history);
    }
  } catch (e) {
    if (typeof thinking !== "undefined" && document.contains(thinking)) thinking.remove();
    addMsg("error", "connection failed: " + e.message);
  } finally {
    send.disabled = false;
    input.disabled = false;
    input.focus();
  }
}

send.addEventListener("click", sendMessage);
input.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); sendMessage(); }
});
// Save session on tab close / navigation. sendBeacon is fire-and-forget,
// reliable even during unload when fetch() would be cancelled.
window.addEventListener("beforeunload", () => {
  navigator.sendBeacon(
    "/conversations/" + convId + "/save",
    new Blob([JSON.stringify({})], {type: "application/json"}),
  );
});
input.focus();
</script>
</body>
</html>
