<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>tars</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: system-ui, -apple-system, sans-serif; background: #1a1a1a; color: #e0e0e0; height: 100dvh; display: flex; flex-direction: column; }
  #messages { flex: 1; overflow-y: auto; padding: 1rem; display: flex; flex-direction: column; gap: 0.5rem; }
  .msg { max-width: 80%; padding: 0.5rem 0.75rem; border-radius: 0.5rem; line-height: 1.4; word-wrap: break-word; }
  .msg.user { white-space: pre-wrap; align-self: flex-end; background: #2563eb; color: #fff; }
  .msg.assistant { align-self: flex-start; background: #2a2a2a; overflow-wrap: break-word; }
  /* Markdown inside assistant messages */
  .msg.assistant p { margin: 0.4em 0; }
  .msg.assistant p:first-child { margin-top: 0; }
  .msg.assistant p:last-child { margin-bottom: 0; }
  .msg.assistant pre { background: #1a1a1a; padding: 0.5rem; border-radius: 0.375rem; overflow-x: auto; margin: 0.4em 0; }
  .msg.assistant code { font-family: ui-monospace, "SF Mono", Menlo, monospace; font-size: 0.9em; }
  .msg.assistant :not(pre) > code { background: #1a1a1a; padding: 0.1em 0.3em; border-radius: 0.25rem; }
  .msg.assistant ul, .msg.assistant ol { margin: 0.4em 0; padding-left: 1.5em; }
  .msg.assistant li { margin: 0.2em 0; }
  .msg.assistant blockquote { border-left: 3px solid #555; padding-left: 0.75rem; margin: 0.4em 0; color: #aaa; }
  .msg.assistant table { border-collapse: collapse; margin: 0.4em 0; }
  .msg.assistant th, .msg.assistant td { border: 1px solid #444; padding: 0.3em 0.6em; }
  .msg.assistant th { background: #333; }
  .msg.assistant h1, .msg.assistant h2, .msg.assistant h3 { margin: 0.5em 0 0.3em; }
  .msg.assistant a { color: #60a5fa; }
  .msg.error { align-self: flex-start; background: #7f1d1d; }
  .msg.thinking { align-self: flex-start; background: #2a2a2a; color: #888; }
  @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
  .msg.thinking { animation: pulse 1.5s ease-in-out infinite; }
  #input-row { display: flex; gap: 0.5rem; padding: 0.75rem 1rem; background: #222; border-top: 1px solid #333; }
  #input { flex: 1; padding: 0.5rem 0.75rem; border: 1px solid #444; border-radius: 0.375rem; background: #2a2a2a; color: #e0e0e0; font-size: 1rem; font-family: inherit; outline: none; }
  #input:focus { border-color: #2563eb; }
  #send { padding: 0.5rem 1rem; border: none; border-radius: 0.375rem; background: #2563eb; color: #fff; font-size: 1rem; cursor: pointer; }
  #send:disabled { opacity: 0.5; cursor: default; }
</style>
</head>
<body>
<div id="messages"></div>
<div id="input-row">
  <input id="input" type="text" placeholder="message tars..." autocomplete="off">
  <button id="send">Send</button>
</div>
<script src="/marked.min.js"></script>
<script>
// Configure marked for GitHub-Flavored Markdown.
marked.use({gfm: true, breaks: true});

const messages = document.getElementById("messages");
const input = document.getElementById("input");
const send = document.getElementById("send");

// Persist conversation ID in localStorage so the same server-side
// conversation is resumed after a page reload.
const STORAGE_KEY = "tars_conversation";
let convId = localStorage.getItem("tars_convId");
if (!convId) {
  convId = "web-" + Math.random().toString(36).slice(2, 10);
  localStorage.setItem("tars_convId", convId);
}

// --- localStorage history ---
// Store as a JSON array of {role, text} objects. Capped to avoid
// localStorage bloat (5MB limit shared with the whole origin).
const MAX_HISTORY = 200;

function loadHistory() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch { return []; }
}

function saveHistory(history) {
  try {
    // Keep only the most recent messages if we're over the cap.
    const trimmed = history.slice(-MAX_HISTORY);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(trimmed));
  } catch { /* localStorage full or unavailable — ignore */ }
}

function clearConversation() {
  localStorage.removeItem(STORAGE_KEY);
  localStorage.removeItem("tars_convId");
  convId = "web-" + Math.random().toString(36).slice(2, 10);
  localStorage.setItem("tars_convId", convId);
  messages.innerHTML = "";
  history = [];
}

let history = loadHistory();

function addMsg(role, text) {
  const div = document.createElement("div");
  div.className = "msg " + role;
  // Render assistant messages as GFM markdown; everything else as plain text.
  if (role === "assistant") {
    div.innerHTML = marked.parse(text);
  } else {
    div.textContent = text;
  }
  messages.appendChild(div);
  messages.scrollTop = messages.scrollHeight;
  return div;
}

// Restore previous messages on page load.
for (const entry of history) {
  addMsg(entry.role, entry.text);
}

async function sendMessage() {
  const text = input.value.trim();
  if (!text) return;

  // /clear command — reset conversation locally and on server.
  if (text === "/clear") {
    input.value = "";
    try { fetch("/conversations/" + convId, {method: "DELETE"}); } catch {}
    clearConversation();
    return;
  }

  // /w [note] — flag last response as wrong; /r [note] — flag as good.
  const fbMatch = text.match(/^\/([wr])(?:\s(.*))?$/);
  if (fbMatch) {
    input.value = "";
    const kind = fbMatch[1] === "r" ? "reward" : "correction";
    const note = (fbMatch[2] || "").trim();
    try {
      const resp = await fetch("/feedback", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({conversation_id: convId, note, kind}),
      });
      const data = await resp.json();
      addMsg("assistant", resp.ok ? data.message : (data.detail || "feedback failed"));
    } catch (e) {
      addMsg("error", "feedback failed: " + e.message);
    }
    return;
  }

  input.value = "";
  addMsg("user", text);
  history.push({role: "user", text});
  saveHistory(history);
  send.disabled = true;
  input.disabled = true;

  try {
    const resp = await fetch("/chat/stream", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify({conversation_id: convId, message: text}),
    });

    if (!resp.ok) {
      const err = await resp.json();
      addMsg("error", err.detail || "request failed");
      return;
    }

    const thinking = addMsg("thinking", "thinking...");
    const div = addMsg("assistant", "");
    div.style.display = "none";
    let firstToken = true;
    let rawText = "";  // accumulate raw markdown source

    const reader = resp.body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";

    while (true) {
      const {done, value} = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, {stream: true});
      const lines = buffer.split("\n");
      buffer = lines.pop();

      for (const line of lines) {
        if (!line.startsWith("data: ")) continue;
        const data = JSON.parse(line.slice(6));
        if (data.delta) {
          if (firstToken) {
            thinking.remove();
            div.style.display = "";
            firstToken = false;
          }
          rawText += data.delta;
          div.innerHTML = marked.parse(rawText);
          messages.scrollTop = messages.scrollHeight;
        }
      }
    }

    // Save the raw markdown source so history restores render correctly.
    if (rawText) {
      history.push({role: "assistant", text: rawText});
      saveHistory(history);
    }
  } catch (e) {
    if (typeof thinking !== "undefined" && document.contains(thinking)) thinking.remove();
    addMsg("error", "connection failed: " + e.message);
  } finally {
    send.disabled = false;
    input.disabled = false;
    input.focus();
  }
}

send.addEventListener("click", sendMessage);
input.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); sendMessage(); }
});
// Save session on tab close / navigation. sendBeacon is fire-and-forget,
// reliable even during unload when fetch() would be cancelled.
window.addEventListener("beforeunload", () => {
  navigator.sendBeacon(
    "/conversations/" + convId + "/save",
    new Blob([JSON.stringify({})], {type: "application/json"}),
  );
});
input.focus();
</script>
</body>
</html>
