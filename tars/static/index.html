<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>tars</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: system-ui, -apple-system, sans-serif; background: #1a1a1a; color: #e0e0e0; height: 100dvh; display: flex; flex-direction: row; }

  /* --- Sidebar --- */
  #sidebar { width: 260px; background: #161616; border-right: 1px solid #333; display: flex; flex-direction: column; flex-shrink: 0; overflow: hidden; transition: margin-left 0.2s; }
  #sidebar.collapsed { margin-left: -260px; }
  #sidebar-header { padding: 0.75rem; border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center; }
  #sidebar-header h2 { font-size: 0.85rem; font-weight: 600; color: #888; text-transform: uppercase; letter-spacing: 0.05em; }
  #sidebar-toggle { background: none; border: none; color: #888; cursor: pointer; font-size: 1.1rem; padding: 0.25rem; }
  #sidebar-toggle:hover { color: #e0e0e0; }
  .sidebar-section { padding: 0.5rem 0; }
  .sidebar-section-title { font-size: 0.7rem; color: #666; text-transform: uppercase; letter-spacing: 0.05em; padding: 0.25rem 0.75rem; }
  .sidebar-list { list-style: none; overflow-y: auto; max-height: 40vh; }
  .sidebar-item { padding: 0.4rem 0.75rem; cursor: pointer; font-size: 0.85rem; color: #aaa; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; border-left: 3px solid transparent; }
  .sidebar-item:hover { background: #222; color: #e0e0e0; }
  .sidebar-item.active { border-left-color: #2563eb; color: #e0e0e0; background: #1e1e1e; }
  .sidebar-channel { font-size: 0.7rem; color: #666; margin-left: 0.25rem; }
  #sidebar-toggle-btn { position: fixed; top: 0.5rem; left: 0.5rem; z-index: 10; background: #222; border: 1px solid #333; color: #888; cursor: pointer; font-size: 1rem; padding: 0.25rem 0.5rem; border-radius: 0.25rem; display: none; }
  #sidebar-toggle-btn:hover { color: #e0e0e0; }
  #sidebar.collapsed ~ #main #sidebar-toggle-btn { display: block; }

  /* --- Main area --- */
  #main { flex: 1; display: flex; flex-direction: column; min-width: 0; }
  #messages { flex: 1; overflow-y: auto; padding: 1rem; display: flex; flex-direction: column; gap: 0.5rem; }
  .msg { max-width: 80%; padding: 0.5rem 0.75rem; border-radius: 0.5rem; line-height: 1.4; word-wrap: break-word; }
  .msg.user { white-space: pre-wrap; align-self: flex-end; background: #2563eb; color: #fff; }
  .msg.assistant { align-self: flex-start; background: #2a2a2a; overflow-wrap: break-word; }
  /* Markdown inside assistant messages */
  .msg.assistant p { margin: 0.4em 0; }
  .msg.assistant p:first-child { margin-top: 0; }
  .msg.assistant p:last-child { margin-bottom: 0; }
  .msg.assistant pre { background: #1a1a1a; padding: 0.5rem; border-radius: 0.375rem; overflow-x: auto; margin: 0.4em 0; }
  .msg.assistant code { font-family: ui-monospace, "SF Mono", Menlo, monospace; font-size: 0.9em; }
  .msg.assistant :not(pre) > code { background: #1a1a1a; padding: 0.1em 0.3em; border-radius: 0.25rem; }
  .msg.assistant ul, .msg.assistant ol { margin: 0.4em 0; padding-left: 1.5em; }
  .msg.assistant li { margin: 0.2em 0; }
  .msg.assistant blockquote { border-left: 3px solid #555; padding-left: 0.75rem; margin: 0.4em 0; color: #aaa; }
  .msg.assistant table { border-collapse: collapse; margin: 0.4em 0; }
  .msg.assistant th, .msg.assistant td { border: 1px solid #444; padding: 0.3em 0.6em; }
  .msg.assistant th { background: #333; }
  .msg.assistant h1, .msg.assistant h2, .msg.assistant h3 { margin: 0.5em 0 0.3em; }
  .msg.assistant a { color: #60a5fa; }
  .msg.error { align-self: flex-start; background: #7f1d1d; }
  .msg.thinking { align-self: flex-start; background: #2a2a2a; color: #888; }
  @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
  .msg.thinking { animation: pulse 1.5s ease-in-out infinite; }
  .model-tag { font-size: 0.7rem; color: #555; margin-top: 0.15rem; align-self: flex-start; }
  #input-row { display: flex; gap: 0.5rem; padding: 0.75rem 1rem; background: #222; border-top: 1px solid #333; }
  #input { flex: 1; padding: 0.5rem 0.75rem; border: 1px solid #444; border-radius: 0.375rem; background: #2a2a2a; color: #e0e0e0; font-size: 1rem; font-family: inherit; outline: none; }
  #input:focus { border-color: #2563eb; }
  #send { padding: 0.5rem 1rem; border: none; border-radius: 0.375rem; background: #2563eb; color: #fff; font-size: 1rem; cursor: pointer; }
  #send:disabled { opacity: 0.5; cursor: default; }

  /* Session viewer overlay */
  .session-viewer { white-space: pre-wrap; font-size: 0.85rem; color: #bbb; padding: 1rem; overflow-y: auto; flex: 1; }
  .session-viewer h1, .session-viewer h2, .session-viewer h3 { color: #e0e0e0; }
</style>
</head>
<body>
<div id="sidebar">
  <div id="sidebar-header">
    <h2>tars</h2>
    <button id="sidebar-toggle" title="Hide sidebar">&laquo;</button>
  </div>
  <div class="sidebar-section">
    <div class="sidebar-section-title">Active</div>
    <ul id="active-list" class="sidebar-list"></ul>
  </div>
  <div class="sidebar-section">
    <div class="sidebar-section-title">History</div>
    <ul id="history-list" class="sidebar-list"></ul>
  </div>
</div>
<div id="main">
  <button id="sidebar-toggle-btn" title="Show sidebar">&raquo;</button>
  <div id="messages"></div>
  <div id="input-row">
    <input id="input" type="text" placeholder="message tars..." autocomplete="off">
    <button id="send">Send</button>
  </div>
</div>
<script src="/marked.min.js"></script>
<script>
// Configure marked for GitHub-Flavored Markdown.
marked.use({gfm: true, breaks: true});

const messagesEl = document.getElementById("messages");
const inputEl = document.getElementById("input");
const sendBtn = document.getElementById("send");
const sidebar = document.getElementById("sidebar");
const activeList = document.getElementById("active-list");
const historyList = document.getElementById("history-list");

// Persist conversation ID in localStorage so the same server-side
// conversation is resumed after a page reload.
const STORAGE_KEY = "tars_conversation";
let convId = localStorage.getItem("tars_convId");
if (!convId) {
  convId = "web-" + Math.random().toString(36).slice(2, 10);
  localStorage.setItem("tars_convId", convId);
}

// --- auth token (optional) ---
const tokenParam = new URLSearchParams(window.location.search).get("token");
if (tokenParam) {
  localStorage.setItem("tarsToken", tokenParam);
}
const authToken = localStorage.getItem("tarsToken") || "";
const authHeaders = (extra = {}) => {
  if (!authToken) return extra;
  return {...extra, "Authorization": "Bearer " + authToken};
};

// --- localStorage history ---
// Store as a JSON array of {role, text, model?} objects. Capped to avoid
// localStorage bloat (5MB limit shared with the whole origin).
const MAX_HISTORY = 200;

function loadHistory() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch { return []; }
}

function saveHistory(history) {
  try {
    const trimmed = history.slice(-MAX_HISTORY);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(trimmed));
  } catch { /* localStorage full or unavailable */ }
}

function clearConversation() {
  localStorage.removeItem(STORAGE_KEY);
  localStorage.removeItem("tars_convId");
  convId = "web-" + Math.random().toString(36).slice(2, 10);
  localStorage.setItem("tars_convId", convId);
  messagesEl.innerHTML = "";
  history = [];
}

let history = loadHistory();

function addMsg(role, text, model) {
  const div = document.createElement("div");
  div.className = "msg " + role;
  if (role === "assistant") {
    div.innerHTML = marked.parse(text);
  } else {
    div.textContent = text;
  }
  messagesEl.appendChild(div);
  if (model && role === "assistant") {
    const tag = document.createElement("div");
    tag.className = "model-tag";
    tag.textContent = model;
    messagesEl.appendChild(tag);
  }
  messagesEl.scrollTop = messagesEl.scrollHeight;
  return div;
}

function addModelTag(model) {
  const tag = document.createElement("div");
  tag.className = "model-tag";
  tag.textContent = model;
  messagesEl.appendChild(tag);
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

// Restore previous messages on page load.
for (const entry of history) {
  addMsg(entry.role, entry.text, entry.model);
}

// --- Sidebar ---
document.getElementById("sidebar-toggle").addEventListener("click", () => {
  sidebar.classList.add("collapsed");
});
document.getElementById("sidebar-toggle-btn").addEventListener("click", () => {
  sidebar.classList.remove("collapsed");
});

let viewingSession = false;

async function loadSidebar() {
  // Active conversations
  try {
    const resp = await fetch("/conversations", {headers: authHeaders()});
    const data = await resp.json();
    activeList.innerHTML = "";
    for (const c of data.conversations) {
      const li = document.createElement("li");
      li.className = "sidebar-item" + (c.id === convId ? " active" : "");
      li.textContent = c.id;
      li.title = `${c.message_count} messages`;
      li.addEventListener("click", () => loadConversation(c.id));
      activeList.appendChild(li);
    }
  } catch {}

  // Session history
  try {
    const resp = await fetch("/sessions?limit=20", {headers: authHeaders()});
    const data = await resp.json();
    historyList.innerHTML = "";
    for (const s of data.sessions) {
      const li = document.createElement("li");
      li.className = "sidebar-item";
      const channelSpan = s.channel ? `<span class="sidebar-channel">[${s.channel}]</span>` : "";
      li.innerHTML = `${s.title} ${channelSpan}`;
      li.title = s.date;
      li.addEventListener("click", () => viewSession(s.filename, s.title));
      historyList.appendChild(li);
    }
  } catch {}
}

async function loadConversation(id) {
  if (viewingSession) {
    // Restore chat view
    messagesEl.innerHTML = "";
    viewingSession = false;
    document.getElementById("input-row").style.display = "";
  }
  try {
    const resp = await fetch(`/conversations/${id}/messages`, {headers: authHeaders()});
    const data = await resp.json();
    messagesEl.innerHTML = "";
    for (const m of data.messages) {
      addMsg(m.role, m.content);
    }
    convId = id;
    localStorage.setItem("tars_convId", convId);
    // Clear local history and replace with server messages
    history = data.messages.map(m => ({role: m.role, text: m.content}));
    saveHistory(history);
  } catch (e) {
    addMsg("error", "Failed to load conversation: " + e.message);
  }
  loadSidebar();
}

async function viewSession(filename, title) {
  try {
    const resp = await fetch(`/sessions/${encodeURIComponent(filename)}`, {headers: authHeaders()});
    if (!resp.ok) { addMsg("error", "Session not found"); return; }
    const data = await resp.json();
    messagesEl.innerHTML = "";
    viewingSession = true;
    document.getElementById("input-row").style.display = "none";
    const viewer = document.createElement("div");
    viewer.className = "session-viewer";
    viewer.innerHTML = marked.parse(data.content);
    messagesEl.appendChild(viewer);
    // Highlight in sidebar
    historyList.querySelectorAll(".sidebar-item").forEach(el => el.classList.remove("active"));
    const items = historyList.querySelectorAll(".sidebar-item");
    for (const item of items) {
      if (item.title === title || item.textContent.includes(title)) {
        item.classList.add("active");
        break;
      }
    }
  } catch (e) {
    addMsg("error", "Failed to load session: " + e.message);
  }
}

// Return to chat from session view
function returnToChat() {
  if (!viewingSession) return;
  viewingSession = false;
  document.getElementById("input-row").style.display = "";
  messagesEl.innerHTML = "";
  for (const entry of history) {
    addMsg(entry.role, entry.text, entry.model);
  }
  loadSidebar();
}

function parseToolCommand(text) {
  const parts = text.split(/\s+/);
  const cmd = parts[0];
  if (cmd === "/todoist") {
    const sub = parts[1] || "";
    if (sub === "add" && parts.length > 2) {
      const flags = new Set(["--due", "--project", "--priority"]);
      const args = {content: ""};
      const content = [];
      for (let i = 2; i < parts.length; i++) {
        if (flags.has(parts[i]) && i + 1 < parts.length) {
          const flag = parts[i].slice(2);
          const vals = [];
          i++;
          while (i < parts.length && !flags.has(parts[i])) { vals.push(parts[i++]); }
          i--;
          args[flag] = flag === "priority" ? parseInt(vals.join(" ")) : vals.join(" ");
        } else { content.push(parts[i]); }
      }
      args.content = content.join(" ");
      return {name: "todoist_add_task", args};
    }
    if (sub === "today") return {name: "todoist_today", args: {}};
    if (sub === "upcoming") { const d = parseInt(parts[2]); return {name: "todoist_upcoming", args: {days: Number.isNaN(d) ? 7 : d}}; }
    if (sub === "complete" && parts.length > 2) return {name: "todoist_complete_task", args: {ref: parts.slice(2).join(" ")}};
    return null;
  }
  if (cmd === "/weather") return {name: "weather_now", args: {}};
  if (cmd === "/forecast") return {name: "weather_forecast", args: {}};
  if (cmd === "/memory") return {name: "memory_recall", args: {}};
  if (cmd === "/remember" && parts.length >= 3) return {name: "memory_remember", args: {section: parts[1], content: parts.slice(2).join(" ")}};
  if (cmd === "/note" && parts.length >= 2) return {name: "note_daily", args: {content: parts.slice(1).join(" ")}};
  if (cmd === "/note") return "usage";
  if (cmd === "/read" && parts.length >= 2) return {name: "web_read", args: {url: parts[1]}};
  if (cmd === "/read") return "usage_read";
  return null;
}

async function sendMessage() {
  const text = inputEl.value.trim();
  if (!text) return;

  // Return to chat if viewing a session
  if (viewingSession) returnToChat();

  // /clear command — reset conversation locally and on server.
  if (text === "/clear") {
    inputEl.value = "";
    try { fetch("/conversations/" + convId, {method: "DELETE", headers: authHeaders()}); } catch {}
    clearConversation();
    loadSidebar();
    return;
  }

  // /help — show available commands.
  if (text === "/help") {
    inputEl.value = "";
    addMsg("assistant", [
      "**tools:**",
      "`/todoist add <text> [--due D] [--project P] [--priority N]`",
      "`/todoist today|upcoming [days]|complete <ref>`",
      "`/weather` — current conditions",
      "`/forecast` — today's hourly forecast",
      "`/memory` — show persistent memory",
      "`/remember <semantic|procedural> <text>`",
      "`/note <text>` — append to today's daily note",
      "`/read <url>` — fetch and display a web page",
      "**search:**",
      "`/search <query>` — hybrid keyword + semantic",
      "`/sgrep <query>` — keyword (FTS5/BM25)",
      "`/svec <query>` — semantic (vector KNN)",
      "`/find <query>` — search personal notes vault",
      "**sessions:**",
      "`/sessions` — list recent sessions",
      "`/session <query>` — search session logs",
      "**feedback:**",
      "`/w [note]` — flag last response as wrong",
      "`/r [note]` — flag last response as good",
      "**daily:**",
      "`/brief` — todoist + weather digest",
      "**export:**",
      "`/export` — export conversation as markdown",
      "**system:**",
      "`/mcp` — show connected MCP servers",
      "`/schedule` — show installed schedules",
      "`/stats` — memory and index health",
      "`/model` — show active model configuration",
      "`/clear` — reset conversation",
      "`/help` — this help",
    ].join("\n"));
    return;
  }

  // CLI-only interactive commands.
  if (text === "/review" || text === "/tidy" || text.startsWith("/capture")) {
    inputEl.value = "";
    addMsg("assistant", `\`${text}\` is only available in the CLI`);
    return;
  }

  // /mcp — show connected MCP servers.
  if (text === "/mcp") {
    inputEl.value = "";
    addMsg("user", text);
    try {
      const resp = await fetch("/mcp", {headers: authHeaders()});
      const data = await resp.json();
      if (!data.servers.length) {
        addMsg("assistant", "no MCP servers connected");
      } else {
        const lines = data.servers.map(s => {
          const tools = s.tools && s.tools.length ? s.tools.join(", ") : "none";
          return `**${s.name}** (${s.tool_count} tools): ${tools}`;
        });
        addMsg("assistant", lines.join("\n"));
      }
    } catch (e) {
      addMsg("error", "mcp failed: " + e.message);
    }
    return;
  }

  // /schedule — show installed schedules.
  if (text === "/schedule") {
    inputEl.value = "";
    addMsg("user", text);
    try {
      const resp = await fetch("/schedule", {headers: authHeaders()});
      const data = await resp.json();
      const lines = [];
      if (data.os && data.os.length) {
        lines.push("**os schedules:**");
        for (const s of data.os) {
          lines.push(`\`${s.name}\` — ${s.trigger} (last: ${s.last_run || "never"})`);
        }
      }
      if (data.in_process && data.in_process.length) {
        if (lines.length) lines.push("");
        lines.push("**in-process schedules:**");
        for (const s of data.in_process) {
          lines.push(`\`${s.name}\` — ${s.schedule} → ${s.action} (last: ${s.last_run || "never"})`);
        }
      }
      addMsg("assistant", lines.length ? lines.join("\n") : "no schedules installed");
    } catch (e) {
      addMsg("error", "schedule failed: " + e.message);
    }
    return;
  }

  // /export — export conversation as markdown.
  if (text === "/export") {
    inputEl.value = "";
    addMsg("user", text);
    try {
      const resp = await fetch(`/conversations/${convId}/export`, {headers: authHeaders()});
      const data = await resp.json();
      if (!resp.ok) { addMsg("error", data.detail || "export failed"); return; }
      addMsg("assistant", data.markdown);
    } catch (e) {
      addMsg("error", "export failed: " + e.message);
    }
    return;
  }

  // /w [note] — flag last response as wrong; /r [note] — flag as good.
  const fbMatch = text.match(/^\/([wr])(?:\s(.*))?$/);
  if (fbMatch) {
    inputEl.value = "";
    const kind = fbMatch[1] === "r" ? "reward" : "correction";
    const note = (fbMatch[2] || "").trim();
    try {
      const resp = await fetch("/feedback", {
        method: "POST",
        headers: authHeaders({"Content-Type": "application/json"}),
        body: JSON.stringify({conversation_id: convId, note, kind}),
      });
      const data = await resp.json();
      addMsg("assistant", resp.ok ? data.message : (data.detail || "feedback failed"));
    } catch (e) {
      addMsg("error", "feedback failed: " + e.message);
    }
    return;
  }

  // /brief — compound command, uses dedicated endpoint.
  if (text === "/brief") {
    inputEl.value = "";
    addMsg("user", text);
    try {
      const resp = await fetch("/brief", {headers: authHeaders()});
      const data = await resp.json();
      const lines = [];
      for (const [name, content] of Object.entries(data.sections)) {
        const label = name.replace("todoist_today", "tasks").replace("weather_now", "weather").replace("weather_forecast", "forecast");
        lines.push(`**[${label}]**\n${content}`);
      }
      addMsg("assistant", lines.join("\n\n"));
    } catch (e) {
      addMsg("error", "brief failed: " + e.message);
    }
    return;
  }

  // /stats — system health.
  if (text === "/stats") {
    inputEl.value = "";
    addMsg("user", text);
    try {
      const resp = await fetch("/stats", {headers: authHeaders()});
      const data = await resp.json();
      if (data.error) {
        addMsg("assistant", data.error);
      } else {
        const lines = [
          `**db:** ${data.db_size_mb} MB, ${data.files} files, ${data.chunks} chunks`,
          `**embedding:** ${data.embedding_model} (${data.embedding_dim}d)`,
          `**sessions:** ${data.sessions}`,
        ];
        addMsg("assistant", lines.join("\n"));
      }
    } catch (e) {
      addMsg("error", "stats failed: " + e.message);
    }
    return;
  }

  // /model — model configuration.
  if (text === "/model") {
    inputEl.value = "";
    addMsg("user", text);
    try {
      const resp = await fetch("/model", {headers: authHeaders()});
      const data = await resp.json();
      if (!resp.ok) {
        addMsg("error", data.detail || "model lookup failed");
        return;
      }
      const lines = [
        `**primary:** ${data.primary}`,
        `**remote:** ${data.remote}`,
        `**routing:** ${data.routing_policy}`,
      ];
      addMsg("assistant", lines.join("\n"));
    } catch (e) {
      addMsg("error", "model lookup failed: " + e.message);
    }
    return;
  }

  // /sessions — list recent sessions.
  if (text === "/sessions") {
    inputEl.value = "";
    addMsg("user", text);
    try {
      const resp = await fetch("/sessions", {headers: authHeaders()});
      const data = await resp.json();
      if (!data.sessions.length) {
        addMsg("assistant", "no sessions found");
      } else {
        const lines = data.sessions.map(s => {
          const ch = s.channel ? ` [${s.channel}]` : "";
          return `\`${s.date}\`${ch}  ${s.title}`;
        });
        addMsg("assistant", lines.join("\n"));
      }
    } catch (e) {
      addMsg("error", "sessions failed: " + e.message);
    }
    return;
  }

  // /session (bare) — show usage hint.
  if (text === "/session") {
    inputEl.value = "";
    addMsg("assistant", "usage: `/session <query>`");
    return;
  }

  // /session <query> — search session logs.
  if (text.startsWith("/session ")) {
    const query = text.slice(9).trim();
    if (!query) { addMsg("assistant", "usage: /session <query>"); inputEl.value = ""; return; }
    inputEl.value = "";
    addMsg("user", text);
    try {
      const resp = await fetch(
        "/sessions/search?q=" + encodeURIComponent(query),
        {headers: authHeaders()},
      );
      const data = await resp.json();
      if (!data.results.length) {
        addMsg("assistant", "no session results");
      } else {
        const lines = data.results.map((r, i) =>
          `**${i+1}.** [${r.score.toFixed(3)}] ${r.file_title}:${r.start_line}-${r.end_line}\n${r.content.slice(0, 200)}`
        );
        addMsg("assistant", lines.join("\n\n"));
      }
    } catch (e) {
      addMsg("error", "session search failed: " + e.message);
    }
    return;
  }

  // /search, /sgrep, /svec — memory search commands; /find — notes vault search.
  const searchMatch = text.match(/^\/(search|sgrep|svec|find)(?:\s(.*))?$/);
  if (searchMatch) {
    const cmd = searchMatch[1];
    const mode = {search: "hybrid", sgrep: "fts", svec: "vec"}[cmd];
    const query = (searchMatch[2] || "").trim();
    if (!query) { addMsg("assistant", `usage: /${cmd} <query>`); inputEl.value = ""; return; }
    inputEl.value = "";
    addMsg("user", text);
    try {
      const endpoint = cmd === "find"
        ? `/find?q=${encodeURIComponent(query)}`
        : `/search?q=${encodeURIComponent(query)}&mode=${mode}`;
      const resp = await fetch(endpoint, {headers: authHeaders()});
      const data = await resp.json();
      if (!resp.ok) { addMsg("error", data.detail || "search failed"); return; }
      if (!data.results.length) {
        addMsg("assistant", cmd === "find" ? "no results (notes)" : `no results (${mode})`);
      } else {
        const lines = data.results.map((r, i) =>
          `**${i+1}.** [${r.score.toFixed(3)}] ${r.file_title || r.file_path}:${r.start_line}-${r.end_line} (${r.memory_type})\n${r.content.slice(0, 200)}`
        );
        addMsg("assistant", lines.join("\n\n"));
      }
    } catch (e) {
      addMsg("error", "search failed: " + e.message);
    }
    return;
  }

  // Direct tool commands — bypass the model entirely.
  const toolCmd = parseToolCommand(text);
  if (toolCmd === "usage") {
    inputEl.value = "";
    addMsg("assistant", "usage: `/note <text>`");
    return;
  }
  if (toolCmd === "usage_read") {
    inputEl.value = "";
    addMsg("assistant", "usage: `/read <url>`");
    return;
  }
  if (toolCmd) {
    inputEl.value = "";
    addMsg("user", text);
    try {
      const resp = await fetch("/tool", {
        method: "POST",
        headers: authHeaders({"Content-Type": "application/json"}),
        body: JSON.stringify(toolCmd),
      });
      const data = await resp.json();
      addMsg("assistant", resp.ok ? data.result : (data.detail || "tool failed"));
    } catch (e) {
      addMsg("error", "tool failed: " + e.message);
    }
    return;
  }

  inputEl.value = "";
  addMsg("user", text);
  history.push({role: "user", text});
  saveHistory(history);
  sendBtn.disabled = true;
  inputEl.disabled = true;

  try {
    const resp = await fetch("/chat/stream", {
      method: "POST",
      headers: authHeaders({"Content-Type": "application/json"}),
      body: JSON.stringify({conversation_id: convId, message: text}),
    });

    if (!resp.ok) {
      const err = await resp.json();
      addMsg("error", err.detail || "request failed");
      return;
    }

    const thinking = addMsg("thinking", "thinking...");
    const div = addMsg("assistant", "");
    div.style.display = "none";
    let firstToken = true;
    let rawText = "";
    let modelName = "";

    const reader = resp.body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";

    while (true) {
      const {done, value} = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, {stream: true});
      const lines = buffer.split("\n");
      buffer = lines.pop();

      for (const line of lines) {
        if (!line.startsWith("data: ")) continue;
        const data = JSON.parse(line.slice(6));
        if (data.delta) {
          if (firstToken) {
            thinking.remove();
            div.style.display = "";
            firstToken = false;
          }
          rawText += data.delta;
          div.innerHTML = marked.parse(rawText);
          messagesEl.scrollTop = messagesEl.scrollHeight;
        }
        if (data.meta && data.meta.model) {
          modelName = data.meta.model;
        }
      }
    }

    if (modelName) {
      addModelTag(modelName);
    }

    if (rawText) {
      history.push({role: "assistant", text: rawText, model: modelName || undefined});
      saveHistory(history);
    }

    loadSidebar();
  } catch (e) {
    if (typeof thinking !== "undefined" && document.contains(thinking)) thinking.remove();
    addMsg("error", "connection failed: " + e.message);
  } finally {
    sendBtn.disabled = false;
    inputEl.disabled = false;
    inputEl.focus();
  }
}

sendBtn.addEventListener("click", sendMessage);
inputEl.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); sendMessage(); }
});
// Save session on tab close / navigation. sendBeacon is fire-and-forget,
// reliable even during unload when fetch() would be cancelled.
window.addEventListener("beforeunload", () => {
    navigator.sendBeacon(
      "/conversations/" + convId + "/save",
      new Blob([JSON.stringify({})], {type: "application/json"}),
    );
});
inputEl.focus();
loadSidebar();
</script>
</body>
</html>
